^(?!\/)：先頭がスラッシュ / でないことを保証（否定先読み）

(?!.*\.\.)：どこかに ..（連続ピリオド）が 含まれていたら不合格

[a-zA-Z0-9_\-\/\.]+：許可する文字（英数字、アンダースコア、ハイフン、スラッシュ、ピリオド）

public function rules(): array
{
    return [
        'form.path' => [
            'required',
            'regex:/^(?!\/)(?!.*\.\.)[a-zA-Z0-9_\-\/\.]+$/'
        ],
    ];
}


public function rules(): array
{
  return [
    'form.url' => [
    	'required',
    	'regex:/^(?!.*javascript:)(https?:\/\/[^\s<>"']+|\/[^\s<>"']*)$/i'
    ],
  ];
}


from html.parser import HTMLParser

# 危険タグ・属性・スキーム検出用パーサ
class SecurityTagChecker(HTMLParser):
    def __init__(self):
        super().__init__()
        self.found_danger = False

    def handle_starttag(self, tag, attrs):
        # 危険なタグ
        if tag.lower() in ['script', 'iframe', 'object', 'embed', 'svg']:
            self.found_danger = True
        # 属性チェック
        for attr, value in attrs:
            if attr.lower().startswith('on'):  # onerror, onclick, etc
                self.found_danger = True
            if isinstance(value, str) and 'javascript:' in value.lower():
                self.found_danger = True

# 安全かどうかのチェック関数
def is_html_safe(html: str) -> bool:
    parser = SecurityTagChecker()
    parser.feed(html)
    return not parser.found_danger

# Lambdaハンドラ
def lambda_handler(event, context):
    # ★ 本来はここでDBから取得する
    html = get_html_from_database(event)  # 実装は別途
    if not is_html_safe(html):
        return {
            'statusCode': 400,
            'body': '危険なHTMLが検出されました',
            'headers': {'Content-Type': 'text/plain'}
        }

    return {
        'statusCode': 200,
        'body': html,
        'headers': {'Content-Type': 'text/html'}
    }


ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー


import time

# key -> (html, 最終取得時刻)
html_cache: dict[str, tuple[str, float]] = {}
TTL_SECONDS = 300  # 5分

def get_html(key: str) -> str:
    global html_cache
    cached = html_cache.get(key)

    if cached:
        html, timestamp = cached
        if time.time() - timestamp < TTL_SECONDS:
            return html  # 有効期限内ならキャッシュ使用

    # 期限切れ or キャッシュなしならDBから取得
    html = load_html_from_db(key)
    html_cache[key] = (html, time.time())
    return html
